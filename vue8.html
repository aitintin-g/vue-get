<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>VUE学习</title>
	<style>
		
	</style>
</head>
<body>
	<div id="app">
		 <ul>
        <li v-for="item in items">{{item.message}}</li>  
     </ul>

     <ul>
       <li v-for="(item,index) in items">{{index+':'+item.message}}</li>
     </ul>

     <ul>
       <li v-for="value in object">{{value}}</li>
     </ul>

     <ul>
       <li v-for="(value,key) in object">{{key}}-{{value}}</li>
     </ul>

     <ul>
       <li v-for="item in items" :key="item.id">{{key}}-{{value}}</li>
     </ul>

     <!-- 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by="$index" 。

    这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

    为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)：
     <div v-for="item in items" :key="item.id"></div>
     -->
      <!-- push()
      pop()
      shift()
      unshift()
      splice()
      sort()
      reverse() 
      变异数组
    -->
     <!-- 
      filter()
      concat()
      slice() 
      替换数组
    -->

	</div>

	<script type="text/javascript" src="js/vue.js"></script>
	<script type="text/javascript">
       vm=new Vue({
        	el:'#app',
        	data:{
        		items:[
              {id:1,message:'Foo'},
              {id:2,message:'Bar'}
            ],
          object:{
            firstName:'john',
            lastName:'doe',
            age:30
        	}
        }
        });
        
	</script>
</body>
</html>