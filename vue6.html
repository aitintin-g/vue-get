<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>VUE学习</title>
	<style>
		
	</style>
</head>
<body>
	<div id="app">
		<div>
			{{message.split('').reverse().join('')}}
		</div>
		<p>Original message:{{message}}</p>
        <p>Computed reverse message:{{reversedMessage}}</p>
        <p>methods message:{{changeMessage()}}</p>
        <!-- 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 --> 
        <!-- 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 -->
	</div>

	<script type="text/javascript" src="js/vue.js"></script>
	<script type="text/javascript">
       vm=new Vue({
        	el:'#app',
        	data:{
        		message:'Hello world!'
        	},
        	computed:{
        		reversedMessage:function(){
        			return this.message.split('').reverse().join('')
        		}
        	},
        	methods:{
        	    changeMessage:function(){
        	    	return this.message.split('').reverse().join('')
        	    }  	
        	}
        });
        console.log(vm.reversedMessage);
	</script>
</body>
</html>